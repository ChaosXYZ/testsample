<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Enhanced Basic 3D Game Prototype</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 100%;
            color: #ffffff;
            font-family: Arial, sans-serif;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Enhanced Basic 3D Game Prototype</h1>
        <p>Use WASD or arrow keys to move. Click to shoot.</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
    <script>
        // Basic Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202020);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Player (Gun Model)
        const player = new THREE.Group();

        // Gun Base
        const gunBaseGeometry = new THREE.BoxGeometry(0.5, 0.2, 1);
        const gunBaseMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const gunBase = new THREE.Mesh(gunBaseGeometry, gunBaseMaterial);
        gunBase.position.set(0, 0, 0);
        player.add(gunBase);

        // Gun Barrel
        const gunBarrelGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
        const gunBarrelMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
        const gunBarrel = new THREE.Mesh(gunBarrelGeometry, gunBarrelMaterial);
        gunBarrel.rotation.z = Math.PI / 2;
        gunBarrel.position.set(0.25, 0, 0);
        player.add(gunBarrel);

        // Gun Handle
        const gunHandleGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.2);
        const gunHandleMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const gunHandle = new THREE.Mesh(gunHandleGeometry, gunHandleMaterial);
        gunHandle.position.set(-0.2, -0.15, 0);
        player.add(gunHandle);

        player.position.set(0, 0.5, 5);
        scene.add(player);

        // Obstacles
        const obstacles = [];
        const obstacleGeometry = new THREE.BoxGeometry(2, 2, 2);
        const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        for (let i = 0; i < 20; i++) {
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(
                (Math.random() - 0.5) * 50,
                1,
                (Math.random() - 0.5) * 50
            );
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        // Enemies
        const enemies = [];
        const enemyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const enemyCount = 10;
        for (let i = 0; i < enemyCount; i++) {
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            resetEnemyPosition(enemy);
            scene.add(enemy);
            enemies.push(enemy);
        }

        function resetEnemyPosition(enemy) {
            enemy.position.set(
                (Math.random() - 0.5) * 40,
                0.5,
                (Math.random() - 0.5) * 40
            );
        }

        // Bullets
        const bullets = [];
        const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const bulletMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });

        // Controls
        const keysPressed = {};

        document.addEventListener('keydown', (event) => {
            keysPressed[event.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (event) => {
            keysPressed[event.key.toLowerCase()] = false;
        });

        // Shooting
        document.addEventListener('mousedown', (event) => {
            shoot();
        });

        function shoot() {
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            // Start at player's position
            const gunWorldPosition = new THREE.Vector3();
            player.getWorldPosition(gunWorldPosition);
            bullet.position.set(gunWorldPosition.x + 0.5, gunWorldPosition.y, gunWorldPosition.z);
            // Direction: camera's forward vector
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            bullet.userData = {
                velocity: direction.multiplyScalar(20), // Speed of bullet
                gravity: new THREE.Vector3(0, -9.81, 0), // Gravity
            };
            scene.add(bullet);
            bullets.push(bullet);
        }

        // Collision Detection Helper
        function checkCollision(obj1, obj2) {
            const box1 = new THREE.Box3().setFromObject(obj1);
            const box2 = new THREE.Box3().setFromObject(obj2);
            return box1.intersectsBox(box2);
        }

        // Game Loop
        const clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();

            // Player Movement
            const moveSpeed = 10 * delta;
            let moveX = 0, moveZ = 0;
            if (keysPressed['w'] || keysPressed['arrowup']) moveZ -= moveSpeed;
            if (keysPressed['s'] || keysPressed['arrowdown']) moveZ += moveSpeed;
            if (keysPressed['a'] || keysPressed['arrowleft']) moveX -= moveSpeed;
            if (keysPressed['d'] || keysPressed['arrowright']) moveX += moveSpeed;

            // Attempt to move along X axis
            if (moveX !== 0) {
                player.position.x += moveX;
                let collision = false;
                for (let obstacle of obstacles) {
                    if (checkCollision(player, obstacle)) {
                        collision = true;
                        break;
                    }
                }
                if (collision) {
                    player.position.x -= moveX;
                }
            }

            // Attempt to move along Z axis
            if (moveZ !== 0) {
                player.position.z += moveZ;
                let collision = false;
                for (let obstacle of obstacles) {
                    if (checkCollision(player, obstacle)) {
                        collision = true;
                        break;
                    }
                }
                if (collision) {
                    player.position.z -= moveZ;
                }
            }

            // Update camera to follow the player
            camera.position.x = player.position.x;
            camera.position.z = player.position.z + 5;
            camera.lookAt(player.position.x, player.position.y, player.position.z);

            // Enemies Movement
            enemies.forEach(enemy => {
                const direction = new THREE.Vector3();
                direction.subVectors(player.position, enemy.position).normalize();
                enemy.position.add(direction.multiplyScalar(2 * delta)); // Slowed down speed

                // Keep enemies on the ground
                enemy.position.y = 0.5;

                // Simple collision with player
                if (checkCollision(enemy, player)) {
                    alert("Game Over!");
                    resetGame();
                }

                // Collision with obstacles for enemies
                obstacles.forEach(obstacle => {
                    if (checkCollision(enemy, obstacle)) {
                        // Move enemy back
                        enemy.position.sub(direction.multiplyScalar(2 * delta));
                    }
                });
            });

            // Bullets Movement
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                // Update velocity with gravity
                bullet.userData.velocity.add(bullet.userData.gravity.clone().multiplyScalar(delta));
                // Update position
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));

                // Remove bullet if it goes below the floor or out of bounds
                if (bullet.position.y < 0 || Math.abs(bullet.position.x) > 100 || Math.abs(bullet.position.z) > 100) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (checkCollision(bullet, enemy)) {
                        // Remove enemy and bullet
                        scene.remove(enemy);
                        enemies.splice(j, 1);
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        break;
                    }
                }
            }

            // Collision with obstacles for player is already handled during movement

            // Respawn enemies if all are destroyed
            if (enemies.length === 0) {
                for (let i = 0; i < enemyCount; i++) {
                    const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                    resetEnemyPosition(enemy);
                    scene.add(enemy);
                    enemies.push(enemy);
                }
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        function resetGame() {
            // Reset player position
            player.position.set(0, 0.5, 5);
            // Remove all enemies
            enemies.forEach(enemy => scene.remove(enemy));
            enemies.length = 0;
            // Respawn enemies
            for (let i = 0; i < enemyCount; i++) {
                const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                resetEnemyPosition(enemy);
                scene.add(enemy);
                enemies.push(enemy);
            }
            // Remove all bullets
            bullets.forEach(bullet => scene.remove(bullet));
            bullets.length = 0;
        }

        animate();
    </script>
</body>
</html>