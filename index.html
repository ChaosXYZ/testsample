<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Enhanced 3D Game Prototype with First-Person Camera</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 100%;
            color: #ffffff;
            font-family: Arial, sans-serif;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Enhanced 3D Game Prototype</h1>
        <p>Use WASD or arrow keys to move. Click to shoot. Move the mouse to look around.</p>
    </div>
    <!-- Include Three.js r128 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Basic Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202020);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0); // Typical eye level height

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Player (Gun Model)
        const gun = new THREE.Group();

        // Gun Base
        const gunBaseGeometry = new THREE.BoxGeometry(0.5, 0.2, 1);
        const gunBaseMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const gunBase = new THREE.Mesh(gunBaseGeometry, gunBaseMaterial);
        gunBase.position.set(0, -0.1, -0.5);
        gun.add(gunBase);

        // Gun Barrel
        const gunBarrelGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 8);
        const gunBarrelMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
        const gunBarrel = new THREE.Mesh(gunBarrelGeometry, gunBarrelMaterial);
        gunBarrel.rotation.z = Math.PI / 2;
        gunBarrel.position.set(0.3, 0, 0);
        gun.add(gunBarrel);

        // Gun Handle
        const gunHandleGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.2);
        const gunHandleMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const gunHandle = new THREE.Mesh(gunHandleGeometry, gunHandleMaterial);
        gunHandle.position.set(-0.2, -0.25, 0);
        gun.add(gunHandle);

        // Position the gun in front of the camera
        gun.position.set(0, -0.5, -1); // Adjust as needed
        camera.add(gun);
        scene.add(camera); // Add camera to the scene

        // Obstacles
        const obstacles = [];
        const obstacleGeometry = new THREE.BoxGeometry(2, 2, 2);
        const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        for (let i = 0; i < 20; i++) {
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(
                (Math.random() - 0.5) * 50,
                1,
                (Math.random() - 0.5) * 50
            );
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        // Enemies
        const enemies = [];
        const enemyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const enemyCount = 10;
        for (let i = 0; i < enemyCount; i++) {
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            resetEnemyPosition(enemy);
            scene.add(enemy);
            enemies.push(enemy);
        }

        function resetEnemyPosition(enemy) {
            enemy.position.set(
                (Math.random() - 0.5) * 40,
                0.5,
                (Math.random() - 0.5) * 40
            );
        }

        // Bullets
        const bullets = [];
        const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const bulletMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
        const bulletSpeed = 50; // Increased speed for straighter trajectory
        const bulletGravity = -30; // Increased gravity for further drop

        // Controls
        const keysPressed = {};

        document.addEventListener('keydown', (event) => {
            keysPressed[event.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (event) => {
            keysPressed[event.key.toLowerCase()] = false;
        });

        // Mouse Movement for Camera Rotation
        let isMouseDown = false;
        let prevMouseX = 0;
        let prevMouseY = 0;
        const rotationSpeed = 0.002;

        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
        });

        document.addEventListener('mouseup', (event) => {
            isMouseDown = false;
        });

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                camera.rotation.y -= movementX * rotationSpeed;
                camera.rotation.x -= movementY * rotationSpeed;

                // Limit vertical rotation to prevent flipping
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        });

        // Shooting
        document.addEventListener('mousedown', (event) => {
            if (event.button === 0) { // Left mouse button
                shoot();
            }
        });

        function shoot() {
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

            // Get the camera's world direction
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction).normalize();

            // Set bullet position to the gun's position
            const gunWorldPosition = new THREE.Vector3();
            gun.getWorldPosition(gunWorldPosition);
            bullet.position.copy(gunWorldPosition);

            // Set bullet velocity
            bullet.userData = {
                velocity: direction.clone().multiplyScalar(bulletSpeed),
                gravity: new THREE.Vector3(0, bulletGravity, 0)
            };

            scene.add(bullet);
            bullets.push(bullet);
        }

        // Collision Detection Helper
        function checkCollision(obj1, obj2) {
            const box1 = new THREE.Box3().setFromObject(obj1);
            const box2 = new THREE.Box3().setFromObject(obj2);
            return box1.intersectsBox(box2);
        }

        // Game Loop
        const clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();

            // Player Movement
            const moveSpeed = 10 * delta;
            let moveX = 0, moveZ = 0;
            if (keysPressed['w'] || keysPressed['arrowup']) moveZ -= moveSpeed;
            if (keysPressed['s'] || keysPressed['arrowdown']) moveZ += moveSpeed;
            if (keysPressed['a'] || keysPressed['arrowleft']) moveX -= moveSpeed;
            if (keysPressed['d'] || keysPressed['arrowright']) moveX += moveSpeed;

            // Calculate movement direction based on camera rotation
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();

            const moveVector = new THREE.Vector3();
            moveVector.addScaledVector(direction, moveZ);
            moveVector.addScaledVector(right, moveX);

            // Attempt to move the camera
            camera.position.add(moveVector);

            // Collision detection for camera with obstacles
            for (let obstacle of obstacles) {
                if (checkCollision(camera, obstacle)) {
                    // Revert movement
                    camera.position.sub(moveVector);
                    break;
                }
            }

            // Enemies Movement
            enemies.forEach(enemy => {
                const enemyDirection = new THREE.Vector3();
                enemyDirection.subVectors(camera.position, enemy.position).normalize();
                enemy.position.add(enemyDirection.multiplyScalar(2 * delta)); // Slowed down speed

                // Keep enemies on the ground
                enemy.position.y = 0.5;

                // Simple collision with player (camera)
                if (checkCollision(enemy, camera)) {
                    alert("Game Over!");
                    resetGame();
                }

                // Collision with obstacles for enemies
                obstacles.forEach(obstacle => {
                    if (checkCollision(enemy, obstacle)) {
                        // Move enemy back
                        enemy.position.sub(enemyDirection.multiplyScalar(2 * delta));
                    }
                });
            });

            // Bullets Movement
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                // Update velocity with gravity
                bullet.userData.velocity.add(bullet.userData.gravity.clone().multiplyScalar(delta));
                // Update position
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));

                // Remove bullet if it goes below the floor or out of bounds
                if (bullet.position.y < 0 || Math.abs(bullet.position.x) > 100 || Math.abs(bullet.position.z) > 100) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (checkCollision(bullet, enemy)) {
                        // Remove enemy and bullet
                        scene.remove(enemy);
                        enemies.splice(j, 1);
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        break;
                    }
                }
            }

            // Respawn enemies if all are destroyed
            if (enemies.length === 0) {
                for (let i = 0; i < enemyCount; i++) {
                    const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                    resetEnemyPosition(enemy);
                    scene.add(enemy);
                    enemies.push(enemy);
                }
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        function resetGame() {
            // Reset camera position and rotation
            camera.position.set(0, 1.6, 0);
            camera.rotation.set(0, 0, 0);

            // Remove all enemies
            enemies.forEach(enemy => scene.remove(enemy));
            enemies.length = 0;
            // Respawn enemies
            for (let i = 0; i < enemyCount; i++) {
                const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                resetEnemyPosition(enemy);
                scene.add(enemy);
                enemies.push(enemy);
            }
            // Remove all bullets
            bullets.forEach(bullet => scene.remove(bullet));
            bullets.length = 0;
        }

        animate();
    </script>
</body>
</html>